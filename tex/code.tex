\chapter{Code Listing}
\section{democritus.ml}
\begin{lstlisting}{ocaml}
(* Democritus, adapted from MicroC by Stephen Edwards Columbia University *)
(* Top-level of the MicroC compiler: scan & parse the input,
   check the resulting AST, generate LLVM IR, and dump the module *)

type action = Ast | LLVM_IR | Compile

let _ =
  let action = if Array.length Sys.argv > 1 then
    List.assoc Sys.argv.(1) [ ("-a", Ast);	(* Print the AST only *)
			      ("-l", LLVM_IR);  (* Generate LLVM, don't check *)
			      ("-c", Compile) ] (* Generate, check LLVM IR *)
  else Compile in
  let lexbuf = Lexing.from_channel stdin in
  let ast = Parser.program Scanner.token lexbuf in
  Semant.check ast;
  match action with
    Ast -> print_string (Ast.string_of_program ast)
  | LLVM_IR -> print_string (Llvm.string_of_llmodule (Codegen.translate ast))
  | Compile -> let m = Codegen.translate ast in
    Llvm_analysis.assert_valid_module m;
    print_string (Llvm.string_of_llmodule m)
\end{lstlisting}
\section{scanner.mll}
\begin{lstlisting}{ocaml}
(* Democritus, adapted from MicroC by Stephen Edwards Columbia University *)
(* Ocamllex scanner *)

{ open Parser }

rule token = parse
  [' ' '\t' '\r' '\n'] { token lexbuf } (* Whitespace *)
| "//"     { comment lexbuf }             (* Comments *)
| "/*"     { multicomment lexbuf }           (* Multiline comments *)
| '('      { LPAREN }
| ')'      { RPAREN }
| '{'      { LBRACE }
| '}'      { RBRACE }
| ';'      { SEMI }
| ':'      { COLON }
| ','      { COMMA }
| '+'      { PLUS }
| '-'      { MINUS }
| '*'      { STAR }
| '%'	   { MOD }
| '&'	   { REF }
| '.'      { DOT }
| '/'      { DIVIDE }
| '='      { ASSIGN }
| "=="     { EQ }
| "!="     { NEQ }
| '<'      { LT }
| "<="     { LEQ }
| ">"      { GT }
| ">="     { GEQ }
| "&&"     { AND }
| "||"     { OR }
| "!"      { NOT }
| "if"     { IF }
| "else"   { ELSE }
| "for"    { FOR }
| "return" { RETURN }
| "int"    { INT }
| "float"  { FLOAT }
| "bool"   { BOOL }
| "void"   { VOID }
| "true"   { TRUE }
| "string" { STRTYPE }
| "struct" { STRUCT }
| "*void"  {VOIDSTAR }
| "false"  { FALSE }
| "function" { FUNCTION }
| "cast" { CAST }
| "to" { TO }
| "set" { SET }
| "let"      { LET }
| ['0'-'9']+['.']['0'-'9']+ as lxm { FLOATLITERAL(float_of_string lxm) }
| ['0'-'9']+ as lxm { LITERAL(int_of_string lxm) }
| ['a'-'z' 'A'-'Z']['a'-'z' 'A'-'Z' '0'-'9' '_']* as lxm { ID(lxm) }
| '"'      { read_string (Buffer.create 17) lexbuf }
| eof { EOF }
| _ as char { raise (Failure("illegal character " ^ Char.escaped char)) }

and comment = parse
  "\n" { token lexbuf }
  | _  { comment lexbuf }

and multicomment = parse
  "*/" { token lexbuf }
| _    { multicomment lexbuf }

(* From: realworldocaml.org/v1/en/html/parsing-with-ocamllex-and-menhir.html *)
and read_string buf =
  parse
  | '"'       { STRING (Buffer.contents buf) }
  | '\\' '/'  { Buffer.add_char buf '/'; read_string buf lexbuf }
  | '\\' '\\' { Buffer.add_char buf '\\'; read_string buf lexbuf }
  | '\\' 'b'  { Buffer.add_char buf '\b'; read_string buf lexbuf }
  | '\\' 'f'  { Buffer.add_char buf '\012'; read_string buf lexbuf }
  | '\\' 'n'  { Buffer.add_char buf '\n'; read_string buf lexbuf }
  | '\\' 'r'  { Buffer.add_char buf '\r'; read_string buf lexbuf }
  | '\\' 't'  { Buffer.add_char buf '\t'; read_string buf lexbuf }
  | [^ '"' '\\']+
    { Buffer.add_string buf (Lexing.lexeme lexbuf);
      read_string buf lexbuf
    }
  | _ { raise (Failure("Illegal string character: " ^ Lexing.lexeme lexbuf)) }
  | eof { raise (Failure("String is not terminated")) }
\end{lstlisting}
\section{parser.mly}
\begin{lstlisting}{ocaml}
/* Democritus, adapted from MicroC by Stephen Edwards Columbia University */
/* Ocamlyacc parser */

%{
open Ast;;

let first (a,_,_) = a;;
let second (_,b,_) = b;;
let third (_,_,c) = c;;
%}

%token COLON SEMI LPAREN RPAREN LBRACE RBRACE COMMA
%token PLUS MINUS STAR DIVIDE MOD ASSIGN NOT DOT DEREF REF
%token EQ NEQ LT LEQ GT GEQ TRUE FALSE AND OR
%token LET RETURN IF ELSE FOR INT FLOAT BOOL VOID STRTYPE FUNCTION STRUCT VOIDSTAR CAST TO SET
%token <string> STRING
%token <float> FLOATLITERAL
%token <int> LITERAL
%token <string> ID
%token EOF

%nonassoc NOELSE
%nonassoc ELSE
%nonassoc POINTER
%right ASSIGN
%left OR
%left AND
%left EQ NEQ
%left LT GT LEQ GEQ
%left PLUS MINUS 
%left STAR DIVIDE MOD
%right NOT NEG DEREF REF
%left DOT

%start program
%type <Ast.program> program

%%

program:
  decls EOF { $1 }

decls:
   /* nothing */ { [], [], [] }
 | decls vdecl { ($2 :: first $1), second $1, third $1 }
 | decls fdecl { first $1, ($2 :: second $1), third $1 }
 | decls sdecl { first $1, second $1, ($2 :: third $1) }

fdecl:
   FUNCTION ID LPAREN formals_opt RPAREN typ LBRACE vdecl_list stmt_list RBRACE
     { { typ = $6;
	 fname = $2;
	 formals = $4;
	 locals = List.rev $8;
	 body = List.rev $9 } }

formals_opt:
    /* nothing */ { [] }
  | formal_list   { List.rev $1 }

formal_list:
    ID typ                   { [($2,$1)] }
  | formal_list COMMA ID typ { ($4,$3) :: $1 }

typ:
    INT { Int }
  | FLOAT { Float }
  | BOOL { Bool }
  | VOID { Void }
  | STRTYPE { MyString }
  | STRUCT ID { StructType ($2) }
  | VOIDSTAR { Voidstar }
  | STAR %prec POINTER typ { PointerType ($2) }

vdecl_list:
    /* nothing */    { [] }
  | vdecl_list vdecl { $2 :: $1 }

vdecl:
   LET ID typ SEMI { ($3, $2) }

sdecl:
    STRUCT ID LBRACE vdecl_list RBRACE
      { { sname = $2;
      sformals = $4;
      } }

stmt_list:
    /* nothing */  { [] }
  | stmt_list stmt { $2 :: $1 }

stmt:
    expr SEMI { Expr $1 }
  | RETURN SEMI { Return Noexpr }
  | RETURN expr SEMI { Return $2 }
  | LBRACE stmt_list RBRACE { Block(List.rev $2) }
  | IF LPAREN expr RPAREN stmt %prec NOELSE { If($3, $5, Block([])) }
  | IF LPAREN expr RPAREN stmt ELSE stmt    { If($3, $5, $7) }
  | FOR LPAREN expr_opt SEMI expr SEMI expr_opt RPAREN stmt
     { For($3, $5, $7, $9) }
  | FOR LPAREN expr RPAREN stmt { While($3, $5) }

expr_opt:
    /* nothing */ { Noexpr }
  | expr          { $1 }

expr:
    LITERAL          { Literal($1) }
  | FLOATLITERAL     { FloatLiteral($1) }
  | TRUE             { BoolLit(true) }
  | FALSE            { BoolLit(false) }
  | ID               { Id($1) }
  |STRING	     { MyStringLit($1) } 
  | expr PLUS   expr { Binop($1, Add,   $3) }
  | expr MINUS  expr { Binop($1, Sub,   $3) }
  | expr STAR  expr { Binop($1, Mult,  $3) }
  | expr DIVIDE expr { Binop($1, Div,   $3) }
  | expr MOD expr { Binop($1, Mod,   $3) }
  | expr EQ     expr { Binop($1, Equal, $3) }
  | expr NEQ    expr { Binop($1, Neq,   $3) }
  | expr LT     expr { Binop($1, Less,  $3) }
  | expr LEQ    expr { Binop($1, Leq,   $3) }
  | expr GT     expr { Binop($1, Greater, $3) }
  | expr GEQ    expr { Binop($1, Geq,   $3) }
  | expr AND    expr { Binop($1, And,   $3) }
  | expr OR     expr { Binop($1, Or,    $3) }
  | expr DOT    ID   { Dotop($1, $3) }
/*  | expr DOT    ID ASSIGN expr { SAssign($1, $3, $5) } */
  | CAST expr TO typ { Castop($4, $2) }
  | MINUS expr %prec NEG { Unop(Neg, $2) }
  | STAR expr %prec DEREF { Unop(Deref, $2) }
  | REF expr { Unop(Ref, $2) }
  | NOT expr         { Unop(Not, $2) }
  | expr ASSIGN expr   { Assign($1, $3) }
  | ID LPAREN actuals_opt RPAREN { Call($1, $3) }
  | LPAREN expr RPAREN { $2 }

actuals_opt:
    /* nothing */ { [] }
  | actuals_list  { List.rev $1 }

actuals_list:
    expr                    { [$1] }
  | actuals_list COMMA expr { $3 :: $1 }
\end{lstlisting}
\section{semant.ml}
\begin{lstlisting}{ocaml}
(* Democritus, adapted from MicroC by Stephen Edwards Columbia University *)
(* Semantic checking for compiler *)

open Ast

module StringMap = Map.Make(String)
module StringSet = Set.Make(String)

(* Semantic checking of a program. Returns void if successful,
throws an exception if something is wrong.

Check each global variable, then check each function *)

let check (globals, functions, structs) =

(* Raise an exception if the given list has a duplicate *)
  let report_duplicate exceptf list =
    let rec helper = function
	n1 :: n2 :: _ when n1 = n2 -> raise (Failure (exceptf n1))
      | _ :: t -> helper t
      | [] -> ()
    in helper (List.sort compare list)
  in

  (*Raise an exception if there is a recursive struct dependency*)
  
  let find_sdecl_from_sname struct_type_name =
    try List.find (fun s-> s.sname= struct_type_name) structs 
      with Not_found -> raise (Failure("Struct of name " ^ struct_type_name ^ "not found.")) 
  in
  let rec check_recursive_struct_helper sdecl seen_set =
    let check_if_repeat struct_type_name =
      let found = StringSet.mem struct_type_name seen_set in
      if found then raise (Failure ("recursive struct definition"))
      else check_recursive_struct_helper (find_sdecl_from_sname struct_type_name)  (StringSet.add struct_type_name seen_set)
    in
    let is_struct_field = function
      (StructType s, _) -> check_if_repeat s
     | _ -> () 
    in
    List.iter (is_struct_field) sdecl.sformals
  in
  let check_recursive_struct sdecl =
     check_recursive_struct_helper sdecl StringSet.empty    
  in
  let _ = List.map check_recursive_struct structs
  in
  (* Raise an exception if a given binding is to a void type *)
  let check_not_void exceptf = function
      (Void, n) -> raise (Failure (exceptf n))
    | _ -> ()
  in
  
  (* Raise an exception of the given rvalue type cannot be assigned to
     the given lvalue type *)
  let check_assign lvaluet rvaluet err =
	if (String.compare (string_of_typ lvaluet) (string_of_typ rvaluet)) == 0
	then lvaluet
	else raise err
     (*if lvaluet == rvaluet then lvaluet else raise err*)
  in

  let match_struct_to_accessor a b = 
    let  s1 = try List.find (fun s-> s.sname=a) structs 
      with Not_found -> raise (Failure("Struct of name " ^ a ^ "not found.")) in
    try fst( List.find (fun s-> snd(s)=b) s1.sformals) with
	Not_found -> raise (Failure("Struct " ^ a ^ " does not have field " ^ b))
  in

  let check_access lvaluet rvalues =
     match lvaluet with
       StructType s -> match_struct_to_accessor s rvalues
       | _ -> raise (Failure(string_of_typ lvaluet ^ " is not a struct"))
	
  in

  (**** Checking Global Variables ****)

  List.iter (check_not_void (fun n -> "illegal void global " ^ n)) globals;
   
  report_duplicate (fun n -> "duplicate global " ^ n) (List.map snd globals);

  (**** Checking Functions ****)

  if List.mem "append_strings" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function append_strings may not be defined")) else ();

  if List.mem "int_to_string" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function int_to_string may not be defined")) else ();

  if List.mem "print" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function print may not be defined")) else ();

  if List.mem "thread" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function thread may not be defined")) else ();

  if List.mem "exec_prog" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function exec_prog may not be defined")) else ();

  if List.mem "free" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function free may not be defined")) else ();

  if List.mem "malloc" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function malloc may not be defined")) else ();

  if List.mem "open" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function open may not be defined")) else ();

  if List.mem "close" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function close may not be defined")) else ();

  if List.mem "read" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function read may not be defined")) else ();

  if List.mem "write" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function write may not be defined")) else ();

  if List.mem "lseek" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function lseek may not be defined")) else ();

  if List.mem "sleep" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function sleep may not be defined")) else ();
 
 if List.mem "request_from_server" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function request_from_server may not be defined")) else ();

  if List.mem "memset" (List.map (fun fd -> fd.fname) functions)
  then raise (Failure ("function memset may not be defined")) else ();

  report_duplicate (fun n -> "duplicate function " ^ n)
    (List.map (fun fd -> fd.fname) functions);

  (* Function declaration for a named function *)
  let built_in_decls_funcs = [
      { typ = Void; fname = "print_int"; formals = [(Int, "x")];
      locals = []; body = [] };

      { typ = Void; fname = "printb"; formals = [(Bool, "x")];
      locals = []; body = [] }; 

      { typ = Void; fname = "print_float"; formals = [(Float, "x")];
      locals = []; body = [] }; 

      { typ = Void; fname = "thread"; formals = [(MyString, "func"); (MyString, "arg"); (Int, "nthreads")]; locals = []; body = [] };

      { typ = MyString; fname = "malloc"; formals = [(Int, "size")]; locals = []; body = [] };

     (* { typ = DerefAndSet; fname = "malloc"; formals = [(Int, "size")]; locals = []; body = [] }; *)

      { typ = Int; fname = "open"; formals = [(MyString, "name"); (Int, "flags"); (Int, "mode")]; locals = []; body = [] };

      { typ = Int; fname = "close"; formals = [(Int, "fd")]; locals = []; body = [] };

      { typ = Int; fname = "read"; formals = [(Int, "fd"); (MyString, "buf"); (Int, "count")]; locals = []; body = [] };

      { typ = Int; fname = "write"; formals =  [(Int, "fd"); (MyString, "buf"); (Int, "count")]; locals = []; body = [] };

      { typ = Int; fname = "lseek"; formals =  [(Int, "fd"); (Int, "offset"); (Int, "whence")]; locals = []; body = [] };

      { typ = Int; fname = "sleep"; formals =  [(Int, "seconds")]; locals = []; body = [] };
      
      { typ = Int; fname = "memset"; formals =  [(MyString, "s"); (Int, "val"); (Int, "size")]; locals = []; body = [] };

      { typ = MyString; fname = "request_from_server"; formals = [(MyString, "link")]; locals = []; body = [] } 
;

      { typ = Int; fname = "exec_prog"; formals = [(MyString, "arg1"); (MyString, "arg2"); (MyString, "arg3") ]; locals = []; body = [] };

      { typ = Void; fname = "free"; formals = [(MyString, "tofree")]; locals = []; body = [] }
;

      { typ = Void; fname = "append_strings"; formals = [(MyString, "str1"); (MyString, "str2")]; locals = []; body = [] };
 
     
      { typ = Void; fname = "int_to_string"; formals = [(Int, "n"); (MyString, "buf")]; locals = []; body = [] }
]

  in

 let built_in_decls_names = [ "print_int"; "printb"; "print_float"; "thread"; "malloc"; "open"; "close"; "read"; "write"; "lseek"; "sleep"; "memset"; "request_from_server"; "exec_prog"; "free"; "append_strings"; "int_to_string" ]

  in

  let built_in_decls = List.fold_right2 (StringMap.add)
                        built_in_decls_names
                        built_in_decls_funcs
                        (StringMap.singleton "print"
                                { typ = Void; fname = "print"; formals = [(MyString, "x")];
                                locals = []; body = [] })

  in

  let function_decls = List.fold_left (fun m fd -> StringMap.add fd.fname fd m)
                         built_in_decls functions

  in

  let function_decl s = try StringMap.find s function_decls
       with Not_found -> raise (Failure ("unrecognized function " ^ s))
  in

  let _ = function_decl "main" in (* Ensure "main" is defined *)

  let check_function func =

    List.iter (check_not_void (fun n -> "illegal void formal " ^ n ^
      " in " ^ func.fname)) func.formals;

    report_duplicate (fun n -> "duplicate formal " ^ n ^ " in " ^ func.fname)
      (List.map snd func.formals);

    List.iter (check_not_void (fun n -> "illegal void local " ^ n ^
      " in " ^ func.fname)) func.locals;

    report_duplicate (fun n -> "duplicate local " ^ n ^ " in " ^ func.fname)
      (List.map snd func.locals);

    (* Type of each variable (global, formal, or local *)
    let symbols = List.fold_left (fun m (t, n) -> StringMap.add n t m)
	StringMap.empty (globals @ func.formals @ func.locals )
    in

    let type_of_identifier s =
      try StringMap.find s symbols
      with Not_found -> raise (Failure ("undeclared identifier " ^ s))
    in

    (* Return the type of an expression or throw an exception *)
    let rec expr = function
	Literal _ -> Int
      | FloatLiteral _ -> Float
      | BoolLit _ -> Bool
      | MyStringLit _ -> MyString
      | Id s -> type_of_identifier s
      | Binop(e1, op, e2) as e -> let t1 = expr e1 and t2 = expr e2 in
	(match op with
          Add | Sub | Mult | Div  when t1 = Int && t2 = Int -> Int
        |  Add | Sub | Mult | Div  when t1 = Float && t2 = Float -> Float
	| Mod when t1 = Int && t2 = Int -> Int
	| Equal | Neq when t1 = t2 -> Bool
	| Less | Leq | Greater | Geq when t1 = Int && t2 = Int -> Bool
	| And | Or when t1 = Bool && t2 = Bool -> Bool
        | _ -> raise (Failure ("illegal binary operator " ^
              string_of_typ t1 ^ " " ^ string_of_op op ^ " " ^
              string_of_typ t2 ^ " in " ^ string_of_expr e))
        )
      | Dotop(e1, field) -> let lt = expr e1 in
       	 check_access (lt) (field)
      | Castop(t, _) -> (*check later*) t
      | Unop(op, e) as ex -> let t = expr e in
	 (match op with
	   Neg when t = Int -> Int
	 | Not when t = Bool -> Bool
         | Deref -> (match t with
		PointerType s -> s
		| _ -> raise (Failure("cannot dereference a " ^ string_of_typ t)) )
         | Ref -> PointerType(t) 
	 | _ -> raise (Failure ("illegal unary operator " ^ string_of_uop op ^
	  		   string_of_typ t ^ " in " ^ string_of_expr ex)))
      | Noexpr -> Void
     | Call(fname, actuals) as call -> let fd = function_decl fname in
     
         if List.length actuals != List.length fd.formals then
           raise (Failure ("expecting " ^ string_of_int
             (List.length fd.formals) ^ " arguments in " ^ string_of_expr call))
         else
           List.iter2 (fun (ft, _) e -> let et = expr e in
              ignore (check_assign ft et
                (Failure ("illegal actual argument found " ^ string_of_typ et ^
                " expected " ^ string_of_typ ft ^ " in " ^ string_of_expr e))))
             fd.formals actuals;
           fd.typ
      | Assign(e1, e2) as ex ->
	(match e1 with
		Id s -> 
 			let lt = type_of_identifier s and rt = expr e2 in
     			check_assign (lt) (rt) (Failure ("illegal assignment " ^ string_of_typ lt ^ " = " ^
                           string_of_typ rt ^ " in " ^ string_of_expr ex))
		|Unop(op, _) ->
			(match op with 
				Deref -> expr e2
				|_ -> raise(Failure("whatever"))
			)
		|Dotop (_, _) -> expr e2
		| _ -> raise (Failure("whatever"))
	)

     in

    let check_bool_expr e = if expr e != Bool
     then raise (Failure ("expected Boolean expression in " ^ string_of_expr e))
     else () in

    (* Verify a statement or throw an exception *)
    let rec stmt = function
	Block sl -> let rec check_block = function
           [Return _ as s] -> stmt s
         | Return _ :: _ -> raise (Failure "nothing may follow a return")
         | Block sl :: ss -> check_block (sl @ ss)
         | s :: ss -> stmt s ; check_block ss
         | [] -> ()
        in check_block sl
      | Expr e -> ignore (expr e)
      | Return e -> let t = expr e in if t = func.typ then () else
         raise (Failure ("return gives " ^ string_of_typ t ^ " expected " ^
                         string_of_typ func.typ ^ " in " ^ string_of_expr e))
           
      | If(p, b1, b2) -> check_bool_expr p; stmt b1; stmt b2
      | For(e1, e2, e3, st) -> ignore (expr e1); check_bool_expr e2;
                               ignore (expr e3); stmt st
      | While(p, s) -> check_bool_expr p; stmt s
    in

    stmt (Block func.body)
   
  in
  List.iter check_function functions
\end{lstlisting}
\section{ast.ml}
\begin{lstlisting}{ocaml}
(* Democritus, adapted from MicroC by Stephen Edwards Columbia University *)
(* Abstract Syntax Tree and functions for printing it *)

type op = Add | Sub | Mult | Div | Mod | Equal | Neq | Less | Leq | Greater | Geq |
          And | Or 

type uop = Neg | Not | Deref | Ref

type typ = Int | Float | Bool | Void | MyString | StructType of string | Voidstar | PointerType of typ

type bind = typ * string

type expr =
    Literal of int
  | FloatLiteral of float
  | BoolLit of bool
  | MyStringLit of string
  | Id of string
  | Binop of expr * op * expr
  | Dotop of expr * string 
  | Castop of typ * expr
  | Unop of uop * expr
(*  | SAssign of expr * string * expr *)
  | Assign of expr * expr
  | Call of string * expr list
  | Noexpr

type stmt =
    Block of stmt list
  | Expr of expr
  | Return of expr
  | If of expr * stmt * stmt
  | For of expr * expr * expr * stmt
  | While of expr * stmt

type func_decl = {
    typ : typ;
    fname : string;
    formals : bind list;
    locals : bind list;
    body : stmt list;
  }

type struct_decl = {
    sname: string;
    sformals: bind list;

}

type program = bind list * func_decl list * struct_decl list

(* Pretty-printing functions *)

let string_of_op = function
    Add -> "+"
  | Sub -> "-"
  | Mult -> "*"
  | Div -> "/"
  | Mod -> "%"
  | Equal -> "=="
  | Neq -> "!="
  | Less -> "<"
  | Leq -> "<="
  | Greater -> ">"
  | Geq -> ">="
  | And -> "&&"
  | Or -> "||"

let string_of_uop = function
    Neg -> "-"
  | Not -> "!"
  | Deref -> "*"
  | Ref -> "&"

let rec string_of_typ = function
    Int -> "int"
  | Float -> "float"
  | Bool -> "bool"
  | Void -> "void"
  | MyString -> "string"
  | StructType(s) -> "struct" ^ s
  | Voidstar -> "voidstar"
  | PointerType(s) -> "pointerof" ^ (string_of_typ s)

let rec string_of_expr = function
    Literal(l) -> string_of_int l
  | FloatLiteral(l) -> string_of_float l
  | BoolLit(true) -> "true"
  | BoolLit(false) -> "false"
  | MyStringLit(s) -> s
  | Id(s) -> s
  | Binop(e1, o, e2) ->
      string_of_expr e1 ^ " " ^ string_of_op o ^ " " ^ string_of_expr e2
  | Unop(o, e) -> string_of_uop o ^ string_of_expr e
  | Dotop(e1, e2) -> string_of_expr e1 ^ ". " ^ e2
  | Castop(t, e) -> "(" ^ string_of_typ t ^ ")" ^ string_of_expr e
 (* | SAssign(e1, v, e2) -> string_of_expr(e1) ^ "." ^ v ^ " = " ^ string_of_expr e2 *)
  | Assign(v, e) -> string_of_expr v ^ " = " ^ string_of_expr e
  | Call(f, el) ->
      f ^ "(" ^ String.concat ", " (List.map string_of_expr el) ^ ")"
  | Noexpr -> ""

let rec string_of_stmt = function
    Block(stmts) ->
      "{\n" ^ String.concat "" (List.map string_of_stmt stmts) ^ "}\n"
  | Expr(expr) -> string_of_expr expr ^ ";\n";
  | Return(expr) -> "return " ^ string_of_expr expr ^ ";\n";
  | If(e, s, Block([])) -> "if (" ^ string_of_expr e ^ ")\n" ^ string_of_stmt s
  | If(e, s1, s2) ->  "if (" ^ string_of_expr e ^ ")\n" ^
      string_of_stmt s1 ^ "else\n" ^ string_of_stmt s2
  | For(e1, e2, e3, s) ->
      "for (" ^ string_of_expr e1  ^ " ; " ^ string_of_expr e2 ^ " ; " ^
      string_of_expr e3  ^ ") " ^ string_of_stmt s
  | While(e, s) -> "while (" ^ string_of_expr e ^ ") " ^ string_of_stmt s

let string_of_vdecl (t, id) = string_of_typ t ^ " " ^ id ^ ";\n"

let string_of_fdecl fdecl =
  string_of_typ fdecl.typ ^ " " ^
  fdecl.fname ^ "(" ^ String.concat ", " (List.map snd fdecl.formals) ^
  ")\n{\n" ^
  String.concat "" (List.map string_of_vdecl fdecl.locals) ^
  String.concat "" (List.map string_of_stmt fdecl.body) ^
  "}\n"

let string_of_sdecl sdecl = sdecl.sname

let string_of_program (vars, funcs, structs) =
  String.concat "" (List.map string_of_vdecl vars) ^ "\n" ^
  String.concat "\n" (List.map string_of_fdecl funcs) ^ "\n" ^
  String.concat "\n" (List.map string_of_sdecl structs)
\end{lstlisting}
\section{codegen.ml}
\begin{lstlisting}{ocaml}
module L = Llvm
module A = Ast
module StringMap = Map.Make(String)

let translate (globals, functions, structs) =
  let context = L.global_context () in
  let the_module = L.create_module context "Democritus"
  and i32_t  = L.i32_type  context
(*  and i8_t   = L.i8_type   context *)
  and i1_t   = L.i1_type   context
  and void_t = L.void_type context
  and ptr_t  = L.pointer_type (L.i8_type (context)) 
  and float_t = L.double_type context
  in
		

	let struct_types:(string, L.lltype) Hashtbl.t = Hashtbl.create 50 in

        let add_empty_named_struct_types sdecl =
		let struct_t = L.named_struct_type context sdecl.A.sname in
		Hashtbl.add struct_types sdecl.A.sname struct_t
	in
	let _  =
		List.map add_empty_named_struct_types structs 
	in

	let rec ltype_of_typ = function
		A.Int -> i32_t
	|       A.Float -> float_t
	| 	A.Bool -> i1_t
 	|	A.Void -> void_t
	| 	A.StructType s ->  Hashtbl.find struct_types s
	|	A.MyString -> ptr_t 
	| 	A.Voidstar -> ptr_t 
	|	A.PointerType t -> L.pointer_type (ltype_of_typ t) in 
	let populate_struct_type sdecl = 
		let struct_t = Hashtbl.find struct_types sdecl.A.sname in
		let type_list = Array.of_list(List.map (fun(t, _) -> ltype_of_typ t) sdecl.A.sformals) in
		L.struct_set_body struct_t type_list true
	in 
    ignore(List.map populate_struct_type structs);
  
  let string_option_to_string = function
	None -> ""
	| Some(s) -> s
  in
	
  (*struct_field_index is a map where key is struct name and value is another map*)
  (*in the second map, the key is the field name and the value is the index number*)
  let struct_field_index_list =
	let handle_list m individual_struct = 
		(*list of all field names for that struct*) 
		let struct_field_name_list = List.map snd individual_struct.A.sformals in
		let increment n = n + 1 in
		let add_field_and_index (m, i) field_name =
			(*add each field and index to the second map*)
			(StringMap.add field_name (increment i) m, increment i) in
		(*struct_field_map is the second map, with key = field name and value = index*)
		let struct_field_map = 
			List.fold_left add_field_and_index (StringMap.empty, -1) struct_field_name_list
		in
		(*add field map (the first part of the tuple) to the main map*)
		StringMap.add individual_struct.A.sname (fst struct_field_map) m	
	in
	List.fold_left handle_list StringMap.empty structs	
  in
    (* Declare each global variable; remember its value in a map *)
  let global_vars =
    let global_var m (t, n) =
      let init = L.const_int (ltype_of_typ t) 0
      in StringMap.add n (L.define_global n init the_module) m in
    List.fold_left global_var StringMap.empty globals in

  let append_strings_t = L.function_type void_t [| ptr_t; ptr_t |] in
  let append_strings_func = L.declare_function "append_strings" append_strings_t the_module in

  let int_to_string_t = L.function_type void_t [| i32_t; ptr_t |] in
  let int_to_string_func = L.declare_function "int_to_string" int_to_string_t the_module in

  let printf_t = L.var_arg_function_type i32_t [| ptr_t |] in
  let printf_func = L.declare_function "printf" printf_t the_module in

  let execl_t = L.var_arg_function_type i32_t [| ptr_t |] in
  let execl_func = L.declare_function "exec_prog" execl_t the_module in

  let free_t = L.function_type void_t [| ptr_t |] in
  let free_func = L.declare_function "free" free_t the_module in

  let malloc_t = L.function_type ptr_t [| i32_t |] in
  let malloc_func = L.declare_function "malloc" malloc_t the_module in

  let request_from_server_t = L.function_type ptr_t [| ptr_t |] in
  let request_from_server_func = L.declare_function "request_from_server" request_from_server_t the_module in

  let memset_t = L.function_type ptr_t [| ptr_t; i32_t; i32_t |] in
  let memset_func = L.declare_function "memset" memset_t the_module in

  (* File I/O functions *)
  let open_t = L.function_type i32_t [| ptr_t; i32_t; i32_t |] in
  let open_func = L.declare_function "open" open_t the_module in

  let close_t = L.function_type i32_t [| i32_t |] in
  let close_func = L.declare_function "close" close_t the_module in

  let read_t = L.function_type i32_t [| i32_t; ptr_t; i32_t |] in
  let read_func = L.declare_function "read" read_t the_module in

  let write_t = L.function_type i32_t [| i32_t; ptr_t; i32_t |] in
  let write_func = L.declare_function "write" write_t the_module in 

  let lseek_t = L.function_type i32_t [| i32_t; i32_t; i32_t |] in
  let lseek_func = L.declare_function "lseek" lseek_t the_module in

  let sleep_t = L.function_type i32_t [| i32_t |] in
  let sleep_func = L.declare_function "sleep" sleep_t the_module in

  let default_t = L.function_type ptr_t [|ptr_t|] in
  let default_func = L.declare_function "default_start_routine" default_t the_module in

  let param_ty = L.function_type ptr_t [| ptr_t |] in (* a function that returns void_star and takes as argument void_star *)
let param_ptr = L.pointer_type param_ty in  
let thread_t = L.function_type void_t [| param_ptr; ptr_t; i32_t|] in (*a function that returns void and takes (above) and a voidstar and an int *)
  let thread_func = L.declare_function "init_thread" thread_t the_module in


  (* Define each function (arguments and return type) so we can call it *)
  let function_decls =
    let function_decl m fdecl =
      let name = fdecl.A.fname
      and formal_types =
	Array.of_list (List.map (fun (t,_) -> ltype_of_typ t) fdecl.A.formals)
      in let ftype = L.function_type (ltype_of_typ fdecl.A.typ) formal_types in
      StringMap.add name (L.define_function name ftype the_module, fdecl) m in
    List.fold_left function_decl StringMap.empty functions in
  
  (* Fill in the body of the given function *)
  let build_function_body fdecl =
    let (the_function, _) = StringMap.find fdecl.A.fname function_decls in
    let builder = L.builder_at_end context (L.entry_block the_function) in

    let int_format_str = L.build_global_stringptr "%d\n" "fmt" builder in
    let float_format_str = L.build_global_stringptr "%f\n" "fmt" builder in   
 
    (* Construct the function's "locals": formal arguments and locally
       declared variables.  Allocate each on the stack, initialize their
       value, if appropriate, and remember their values in the "locals" map *)
    let local_vars =
      let add_formal m (t, n) p = L.set_value_name n p;
	let local = L.build_alloca (ltype_of_typ t) n builder in
	ignore (L.build_store p local builder);
	StringMap.add n local m in

      let add_local m (t, n) =
	let local_var = L.build_alloca (ltype_of_typ t) n builder
	in StringMap.add n local_var m in

      let formals = List.fold_left2 add_formal StringMap.empty fdecl.A.formals
          (Array.to_list (L.params the_function)) in
      List.fold_left add_local formals fdecl.A.locals in

    (* Return the value for a variable or formal argument *)
    let lookup n = try StringMap.find n local_vars
                 with Not_found -> try StringMap.find n global_vars
                 with Not_found -> raise (Failure ("undeclared variable " ^ n))
    in

    (* Construct code for an expression; return its value *)
    let rec llvalue_expr_getter builder = function
     	A.Id s -> lookup s
	|A.Dotop(e1, field) ->
		(match e1 with
			A.Id s -> let etype = fst( 
				try List.find (fun t->snd(t)=s) fdecl.A.locals
				with Not_found -> raise (Failure("Unable to find" ^ s ^ "in dotop")))
				in
				(try match etype with
					A.StructType t->
						let index_number_list = StringMap.find t struct_field_index_list in
						let index_number = StringMap.find field index_number_list in
						let struct_llvalue = lookup s in
						let access_llvalue = L.build_struct_gep struct_llvalue index_number "dotop_terminal" builder in
						access_llvalue

				| _ -> raise (Failure("No structype."))
			 with Not_found -> raise (Failure("unable to find" ^ s)) )
		| _ as e1_expr ->  let e1'_llvalue = llvalue_expr_getter builder e1_expr in
			let loaded_e1' = expr builder e1_expr in
			let e1'_lltype = L.type_of loaded_e1' in
			let e1'_struct_name_string_option = L.struct_name e1'_lltype in
			let e1'_struct_name_string = string_option_to_string e1'_struct_name_string_option in
			let index_number_list = StringMap.find e1'_struct_name_string struct_field_index_list in
			let index_number = StringMap.find field index_number_list in
			let access_llvalue = L.build_struct_gep e1'_llvalue index_number "gep_in_dotop" builder in
			access_llvalue )
	
	
	|A.Unop(op, e)  ->
		(match op with
			A.Deref ->
				let e_llvalue = (llvalue_expr_getter builder e) in
			        let e_loaded = L.build_load e_llvalue "loaded_deref" builder in 
				e_loaded
			|_ -> raise (Failure("nooo"))
		)
	|_ -> raise (Failure ("in llvalue_expr_getter but not a dotop!"))
    and
    expr builder = function
	A.Literal i -> L.const_int i32_t i
(*      | A.MyStringLit str -> L.const_stringz context str *)
      | A.FloatLiteral f -> L.const_float float_t f
      | A.MyStringLit str -> L.build_global_stringptr str "tmp" builder
      | A.BoolLit b -> L.const_int i1_t (if b then 1 else 0)
      | A.Noexpr -> L.const_int i32_t 0
      | A.Id s -> L.build_load (lookup s) s builder
      | A.Binop (e1, op, e2) ->
	  let e1' = expr builder e1
	  and e2' = expr builder e2 in
	  (match op with
	    A.Add     -> (let e1_type_string = L.string_of_lltype (L.type_of e1') in 
				(match e1_type_string with
					 "double" -> L.build_fadd 
		      			|"i32" -> L.build_add
					| _ -> raise(Failure("Can only add ints or floats")) ))
	   |A.Sub     -> (let e1_type_string = L.string_of_lltype (L.type_of e1') in 
				(match e1_type_string with
					 "double" -> L.build_fsub 
		      			|"i32" -> L.build_sub
					| _ -> raise(Failure("Can only subtract ints or floats")) ))
	   |A.Mult     -> (let e1_type_string = L.string_of_lltype (L.type_of e1') in 
				(match e1_type_string with
					 "double" -> L.build_fmul
		      			|"i32" -> L.build_mul 	
					| _ -> raise(Failure("Can only multiply ints or floats")) ))
	   |A.Div     -> (let e1_type_string = L.string_of_lltype (L.type_of e1') in 
				(match e1_type_string with
					 "double" -> L.build_fdiv 
		      			|"i32" -> L.build_sdiv
					| _ -> raise(Failure("Can only divide ints or floats")) ))
	  | A.Mod     -> L.build_srem
	  | A.And     -> L.build_and
	  | A.Or      -> L.build_or
	  | A.Equal   -> L.build_icmp L.Icmp.Eq
	  | A.Neq     -> L.build_icmp L.Icmp.Ne
	  | A.Less    -> L.build_icmp L.Icmp.Slt
	  | A.Leq     -> L.build_icmp L.Icmp.Sle
	  | A.Greater -> L.build_icmp L.Icmp.Sgt
	  | A.Geq     -> L.build_icmp L.Icmp.Sge
	  ) e1' e2' "tmp" builder
    | A.Dotop(e1, field) -> let _ = expr builder e1 in
	 (match e1 with
		A.Id s -> let etype = fst( 
			try List.find (fun t->snd(t)=s) fdecl.A.locals
			with Not_found -> raise (Failure("Unable to find" ^ s ^ "in dotop")))
			in
			(try match etype with
				A.StructType t->
					let index_number_list = StringMap.find t struct_field_index_list in
					let index_number = StringMap.find field index_number_list in
					let struct_llvalue = lookup s in
					let access_llvalue = L.build_struct_gep struct_llvalue index_number "dotop_terminal" builder in
					let loaded_access = L.build_load access_llvalue "loaded_dotop_terminal" builder in
					loaded_access

				| _ -> raise (Failure("No structype."))
			 with Not_found -> raise (Failure("unable to find" ^ s)) )
		| _ as e1_expr ->  let e1'_llvalue = llvalue_expr_getter builder e1_expr in
			let loaded_e1' = expr builder e1_expr in
			let e1'_lltype = L.type_of loaded_e1' in
			let e1'_struct_name_string_option = L.struct_name e1'_lltype in
			let e1'_struct_name_string = string_option_to_string e1'_struct_name_string_option in
			let index_number_list = StringMap.find e1'_struct_name_string struct_field_index_list in
			let index_number = StringMap.find field index_number_list in
			let access_llvalue = L.build_struct_gep e1'_llvalue index_number "gep_in_dotop" builder in
			L.build_load access_llvalue "loaded_dotop" builder )
      | A.Unop(op, e) ->
	  let e' = expr builder e in
	  (match op with
	    A.Neg     -> L.build_neg e' "tmp" builder
          | A.Not     -> L.build_not e' "temp" builder
	  | A.Deref -> let e_loaded = L.build_load e' "loaded_deref" builder in
			e_loaded
	  | A.Ref -> let e_llvalue = (llvalue_expr_getter builder e) in
		e_llvalue
	  )
      | A.Castop(ast_cast_type, e) ->
 		let cast_lltype = ltype_of_typ ast_cast_type in
		let e_llvalue = expr builder e in
		L.build_pointercast e_llvalue cast_lltype "plz" builder
      | A.Assign (lhs, e2) -> let e2' = expr builder e2 in
			(match lhs with
			A.Id s ->ignore (L.build_store e2' (lookup s) builder); e2'
			|A.Dotop (e1, field) ->
				(match e1 with 			
					
					A.Id s -> let e1typ = fst(
					try List.find (fun t -> snd(t) = s) fdecl.A.locals
					with Not_found -> raise(Failure("unable to find" ^ s ^ "in Sassign")))
					in
					(match e1typ with
						A.StructType t -> (try 
							let index_number_list = StringMap.find t struct_field_index_list in
							let index_number = StringMap.find field index_number_list in
							let struct_llvalue = lookup s in
							let access_llvalue = L.build_struct_gep struct_llvalue index_number field builder in
							(try (ignore(L.build_store e2' access_llvalue builder);e2')
								with Not_found -> raise (Failure("unable to store " ^ t )) )
							with Not_found -> raise (Failure("unable to find" ^ s)) )
						| _ -> raise (Failure("StructType not found.")))
				|_ as e1_expr -> let e1'_llvalue = llvalue_expr_getter builder e1_expr in 
					let loaded_e1' = expr builder e1_expr in
					let e1'_lltype = L.type_of loaded_e1' in
					let e1'_struct_name_string_option = L.struct_name e1'_lltype in
					let e1'_struct_name_string = string_option_to_string e1'_struct_name_string_option in
					let index_number_list = StringMap.find e1'_struct_name_string struct_field_index_list in
					let index_number = StringMap.find field index_number_list in
					let access_llvalue = L.build_struct_gep e1'_llvalue index_number "gep_in_Sassign" builder in
					let _ = L.build_store e2' access_llvalue builder in
					e2'
				)
			
			 |A.Unop(op, e)  ->
					(match op with
						A.Deref ->
							let e_llvalue = (llvalue_expr_getter builder e) in
						        let e_loaded = L.build_load e_llvalue "loaded_deref" builder in 
							let _ = L.build_store e2' e_loaded builder in
							e2'	
						|_ -> raise (Failure("nooo"))
					)
			 |_ -> raise (Failure("can't match in assign"))
			)
      | A.Call ("print_int", [e]) | A.Call ("printb", [e]) ->
	  L.build_call printf_func [| int_format_str ; (expr builder e) |]
	    "printf" builder
    | A.Call ("print_float", [e]) ->
	L.build_call printf_func [| float_format_str; (expr builder e) |] "printf" builder 

    | A.Call ("print", [e])->
        L.build_call printf_func [| (expr builder e) |] "printf" builder

    | A.Call ("append_strings", e) ->
	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call append_strings_func evald_expr_arr "" builder

    | A.Call ("int_to_string", e) ->
	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call int_to_string_func evald_expr_arr "" builder



    | A.Call ("exec_prog", e) ->
	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call execl_func evald_expr_arr "exec_prog" builder

    | A.Call("free", e) ->
	L.build_call free_func (Array.of_list (List.map (expr builder) e)) "" builder

    | A.Call ("malloc", e) ->
      	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call malloc_func evald_expr_arr "malloc" builder

    | A.Call ("memset", e) ->
	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call memset_func evald_expr_arr "memset" builder

  (* File I/O functions *)
    | A.Call("open", e) ->
	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call open_func evald_expr_arr "open" builder

    | A.Call("close", e) ->
	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
  	L.build_call close_func evald_expr_arr "close" builder

    | A.Call("read", e) ->
	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call read_func evald_expr_arr "read" builder

    | A.Call("write", e) ->
	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call write_func evald_expr_arr "write" builder

    | A.Call("lseek", e) ->
	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call lseek_func evald_expr_arr "lseek" builder

    | A.Call("sleep", e) ->
	let evald_expr_list = List.map (expr builder)e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call sleep_func evald_expr_arr "sleep" builder

    | A.Call ("thread", e)->
(*	L.build_call printf_func [| int_format_str ; L.const_int i32_t 8 |] "printf" builder	*)
	let evald_expr_list = List.map (expr builder)e in
(*	let target_func_strptr = List.hd evald_expr_list in  (* jsut get the string by doing List.hd on e *)
	let target_func_str = L.string_of_llvalue target_func_strptr in *)
	let get_string v = match v with
		| A.MyStringLit i -> i
		| _ -> "" in
	let target_func_str = get_string (List.hd e) in
	(*let target_func_str = Option.default "" Some(target_func_str_opt) in *)
	let target_func_llvalue_opt = L.lookup_function target_func_str the_module in
	let deopt x = match x with
		|Some f -> f
		| None -> default_func in
	let target_func_llvalue = deopt target_func_llvalue_opt in
	let remaining_list = List.tl evald_expr_list in
	let new_arg_list = target_func_llvalue :: remaining_list in
	let new_arg_arr = Array.of_list new_arg_list in
		L.build_call thread_func
		new_arg_arr	
                "" builder

    | A.Call ("request_from_server", e) ->
	let evald_expr_list = List.map (expr builder) e in
	let evald_expr_arr = Array.of_list evald_expr_list in
	L.build_call request_from_server_func evald_expr_arr "request_from_server" builder

     | A.Call (f, act) ->
         let (fdef, fdecl) = StringMap.find f function_decls in
	 let actuals = List.rev (List.map (expr builder) (List.rev act)) in
	 let result = (match fdecl.A.typ with A.Void -> ""
                                            | _ -> f ^ "_result") in
         L.build_call fdef (Array.of_list actuals) result builder
    in

    (* Invoke "f builder" if the current block doesn't already
       have a terminal (e.g., a branch). *)
    let add_terminal builder f =
      match L.block_terminator (L.insertion_block builder) with
	Some _ -> ()
      | None -> ignore (f builder) in
	
    (* Build the code for the given statement; return the builder for
       the statement's successor *)
    let rec stmt builder = function
	A.Block sl -> List.fold_left stmt builder sl
      | A.Expr e -> ignore (expr builder e); builder
      | A.Return e -> ignore (match fdecl.A.typ with
	  A.Void -> L.build_ret_void builder
	| _ -> L.build_ret (expr builder e) builder); builder
      | A.If (predicate, then_stmt, else_stmt) ->
         let bool_val = expr builder predicate in
	 let merge_bb = L.append_block context "merge" the_function in

	 let then_bb = L.append_block context "then" the_function in
	 add_terminal (stmt (L.builder_at_end context then_bb) then_stmt)
	   (L.build_br merge_bb);

	 let else_bb = L.append_block context "else" the_function in
	 add_terminal (stmt (L.builder_at_end context else_bb) else_stmt)
	   (L.build_br merge_bb);

	 ignore (L.build_cond_br bool_val then_bb else_bb builder);
	 L.builder_at_end context merge_bb

      | A.While (predicate, body) ->
	  let pred_bb = L.append_block context "while" the_function in
	  ignore (L.build_br pred_bb builder);

	  let body_bb = L.append_block context "while_body" the_function in
	  add_terminal (stmt (L.builder_at_end context body_bb) body)
	    (L.build_br pred_bb);

	  let pred_builder = L.builder_at_end context pred_bb in
	  let bool_val = expr pred_builder predicate in

	  let merge_bb = L.append_block context "merge" the_function in
	  ignore (L.build_cond_br bool_val body_bb merge_bb pred_builder);
	  L.builder_at_end context merge_bb

      | A.For (e1, e2, e3, body) -> stmt builder
	    ( A.Block [A.Expr e1 ; A.While (e2, A.Block [body ; A.Expr e3]) ] )
    in

    (* Build the code for each statement in the function *)
    let builder = stmt builder (A.Block fdecl.A.body) in

    (* Add a return if the last block falls off the end *)
    add_terminal builder (match fdecl.A.typ with
        A.Void -> L.build_ret_void
      | t -> L.build_ret (L.const_int (ltype_of_typ t) 0))
  in


  List.iter build_function_body functions;

  let llmem = Llvm.MemoryBuffer.of_file "bindings.bc" in
  let llm = Llvm_bitreader.parse_bitcode context llmem in
  ignore(Llvm_linker.link_modules the_module llm Llvm_linker.Mode.PreserveSource);

  the_module

\end{lstlisting}
\section{bindings.c}
\begin{lstlisting}{c}
#include <pthread.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#define BUFSIZE 4096

void append_strings(void *str1, void *str2)
{
    strcat((char *)str1, (char *)str2);
}

void int_to_string(int n, void *buf)
{
    sprintf(buf, "%d", n);
}

int exec_prog(void *str1, void *str2, void *str3)
{

    execl((char *)str1, (char *)str2, (char *)str3, NULL);
    return 0;
}

/*
 * Given a URL, send a GET request.
 */
//void *get_request(void *url, void *filePath)
void *request_from_server(void *urlVoid)
{
    // www.xkcd.com/index.html
    char *urlStr = (char *) urlVoid;
    int idxslash = strchr(urlStr, '/') - urlStr;
    char *url = malloc(idxslash + 1);
    char *filePath = malloc(strlen(urlStr) - (idxslash) + 1);
    memset(url, 0, idxslash - 1);
    memset(filePath, 0, strlen(urlStr) - (idxslash));

    strncat(url, urlStr, idxslash);
    strncat(filePath, urlStr + idxslash, strlen(urlStr) - (idxslash));
    char *fileName = strrchr(urlStr, '/') + 1;

    char *serverIP;
    int sock;   // socket we connect to remote on
    struct sockaddr_in serverAddr;
    struct hostent *he;
    char recvbuf[BUFSIZE];

    if ((he = gethostbyname((char *) url)) == NULL) {
	fprintf(stderr, "gethostbyname() failed.");
        exit(1);
    }

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        fprintf(stderr, "socket() failed.");
        exit(1);
    }
    serverIP = inet_ntoa(*(struct in_addr *)he->h_addr);
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_addr.s_addr = inet_addr(serverIP);
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(80);

    int connected = connect(sock, (struct sockaddr *)&serverAddr, sizeof(serverAddr));
    if(connected < 0) {
	fprintf(stderr, "connect() failed.");
        exit(1);
    }

    // send HTTP request
    if (((char *) url)[strlen((char *) url) - 1] == '/') {
        strcat(url, "index.html");
    }

    snprintf(recvbuf, sizeof(recvbuf), 
            "GET %s HTTP/1.0\r\n"
            "Host: %s:%s\r\n"
            "\r\n",
            filePath, url, "80");
    if (send(sock, recvbuf, strlen(recvbuf), 0) != strlen(recvbuf)) {
        fprintf(stderr, "send() failed.");
        exit(1);
    }

    // wrap the socket with a FILE* so that we can read the socket using fgets()
    FILE *fd;
    if ((fd = fdopen(sock, "rb")) == NULL) {
	fprintf(stderr, "fdopen() failed.");
        exit(1);
    }

    /* check header for valid protocol and status code */
    if (fgets(recvbuf, sizeof(recvbuf), fd) == NULL) {
        fprintf(stderr, "server terminated connection without response.");
        exit(1);
    } 
    if (strncmp("HTTP/1.0 ", recvbuf, 9) != 0 && strncmp("HTTP/1.1 ", recvbuf, 9) != 0) {
	fprintf(stderr, "unknown protocol response: %s.", recvbuf);
	exit(1);
    }
    if (strncmp("200", recvbuf + 9, 3) != 0) {
	fprintf(stderr, "request failed with status code %s.", recvbuf);
	exit(1);
    }
    /* ignore remaining header lines */
    do {
        memset(recvbuf, 0, BUFSIZE);
	if (fgets(recvbuf, sizeof(recvbuf), fd) == NULL) {
            fprintf(stderr, "server terminated connection without sending file.");
            exit(1);
	}
    } while (strcmp("\r\n", recvbuf) != 0);


    char *filePathName = malloc(100);
    memset(filePathName, 0, 100);
    char *last_slash;
    if ((last_slash = strrchr(filePath, '/')) != NULL) {
        if (strlen(last_slash) == 1) {
             strcpy(filePathName, "index.html");
        } else {
             strcpy(filePathName, last_slash + 1);
        }
    }
    
    /* open and read into file */
    printf("%s\n", filePathName);
    FILE *outputFile = fopen(filePathName, "wb");
    if (outputFile == NULL) {
	fprintf(stderr, "fopen() failed.");
        exit(1);
    }

    size_t n;
    int total = 0;
    memset(recvbuf, 0, BUFSIZE);
    printf("buffer contents: %s\n", recvbuf);
    while ((n = fread(recvbuf, 1, BUFSIZE, fd)) > 0) {
	if (fwrite(recvbuf, 1, n, outputFile) != n) {
	    fprintf(stderr, "fwrite() failed.");
            exit(1);
	}
        memset(recvbuf, 0, BUFSIZE);
	total += n;
    }
    fprintf(outputFile, "\n");
    fprintf(stderr, "total bytes written: %d\n", total);
    
    if (ferror(fd)) {
	fprintf(stderr, "fread() failed.");
        exit(1);
    }

    fclose(outputFile);
    fclose(fd);
 
    return NULL;
}

void *default_start_routine(void *arg)
{
    return arg;
}

void init_thread(void *(*start_routine) (void *), void *arg, int nthreads)
{
    pthread_t thread[nthreads];
    int i;
    for (i = 0; i < nthreads; i ++) {
	pthread_create(&thread[i], NULL, start_routine, arg);
    }

    for (i = 0; i < nthreads; i++) {
	pthread_join(thread[i], NULL);
    }
}
\end{lstlisting}
