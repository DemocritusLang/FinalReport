\chapter{Testing}
  As with any software project, extensive testing was required to verify that all the features being implemented were working properly. 

\section{Integration Testing}

    \subsection{Development and Testing Process}
    Development of new features required making them pass through the scanner, parser, semantic analyzer, and then code generation, in that order. When envisioning or developing a new feature, the testing process would proceed as follows:
    
    \begin{enumerate}
      \item Write example code implementing and utilizing the desired feature. (E.g. writing a struct definition in a new test file).
      \item Modify the scanner (if needed) to read new tokens required by the new feature.
      \item Modify the parser (usually needed) to change the grammar of the program to accept the new feature and pass necessary information (E.g. struct field names) to the semantic analyzer.
      \item Modify the example code and test it so that only the `correct' implementation of the feature passes the parser. Modify the scanner and parser until this step passes.
      \item Modify the semantic analyzer so that it detects possible semantic issues that could arise from utilization of the new feature (E.g. accessing an undefined field in a struct or an undefined struct).
      \item Modify the example code and test it so that only the `correct' implementation passes the semantic analyzer; try testing multiple cases that should cause the analyzer to raise an error. Modify the semantic analyzer until this step passes.
      \item Modify the code generator so that it generates the appropriate LLVM IR representing your new feature (E.g., allocating the correct amount of memory for new structs, building a map of struct field indexes, calling \texttt{LLVM.build\_struct\_gep}, etc.).
      \item Modify your example code to utilize your feature and produce some visible effect or output (E.g. assigning a struct field, doing arithmetic on it, then printing it).
      \item Test the code and ensure that running the program produces the expected output or effect; continue working on code generation until it does.
    \end{enumerate}
    
    \medskip \noindent
    The process of writing test code, compiling it, and observing its output after being run as LLVM IR was the integration testing method that the Democritus team utilized throughout development. It helped ensure that whole features were working properly, and that the language, built up from multiple features, was still functioning correctly. Integration testing was done on all new features added to the language, as well as the existing ones from MicroC (such as basic variable assignment, conditional iteration, etc).  

	\subsection{Aside: Unit Testing}
    Unit testing was not overly utilized in this development process, besides for testing to ensure that new features could pass certain layers of the compiler while working towards a passing integration test. This is because unit tests can still pass, while whole features lose vertical integration in the process of building up a compiler. This is because new features may often conflict with each other and the successful introduction of one feature could very well mean the breaking of another. This leads us to the test suite and automated regression testing.

\section{The Test Suite and Automated Regression Testing}
  Democritus' test suite was built upon MicroC's automated regression testing package. Within the \texttt{tests} directory, there are dozens of integration test files for various language features as well as their expected \texttt{stdout} output. Additionally, there are several `fail' tests used for showing invalid Democritus code as well as their expected error outputs. 

  \medskip \noindent
  The automated regression testing suite was used to quickly test all major language features by compiling each test, writing the error thrown by compilation (if it was a failure) or output of running the LLVM file (if compilation was a success) to a temporary file, and comparing that output to the expected output of each test with \texttt{diff}. The automated test was a shell script, invoked with \verb|./testall.sh| in the Democritus root directory.

  \medskip \noindent
  The test suite was used frequently throughout development; while developing new features, team members would utilize the test suite to ensure that all major features of the language were still working. If a certain test in the suite failed, more verbose information about the test's failure could be accessed in the \texttt{testall.log} file generated by the testing suite. The automated regression testing was crucial in ensuring that the language stayed consistent and working, and that our master branch remained `updated' and error-free.


